**Socket Programming to Implement**

**Relay Based Peer to Peer System**



> **Introduction :**
>
> This is a Relay based Peer-to-Peer System using Client-Server socket
> programming.In this System Peer_Client, Relay_Server and Peer_Nodes
> communicate with each other based on TCP sockets.
>
> This System works in three phase shown below:
>
> ![](IMAGES/media/image1.png)
>
> **Phase 1 :** The Peer_Nodes (peer 1/2/3 as shown in Figure 1) will
> connect to the Relay_Server using the TCP port already known to them.
> After successful connection, all the Peer_Nodes provide their
> information (IP address and PORT) to the Relay_Server and close the
> connections (as shown in Figure 1). The Relay_Server actively
> maintains all the received information with it. Now the Peer_Nodes
> will act as servers and wait to accept connection from Peer_Clients
> (refer phase three).
>
> **Phase 2 :** The Peer_Client will connect to the Relay_Server using
> the server's TCP port already known toit. After successful connection;
> it will request the Relay_Server for active Peer_Nodes information (as
> shown in Figure 2). The
>
> Relay_Server will respond to the Peer_Client with the active
> Peer_Nodes information currently having it. On receiving the response
> message from the Relay_Server, the Peer_Client closes the connection
> gracefully.
>
> **Phase 3 :** A set of files (say, \*.txt) are distributed evenly
> among the three Peer_Nodes. The Peer_Client will take "file_Name" as
> an input from the user. Then it connects to the Peer_Nodes one at a
> time using the response information. After successful connection, the
> Peer_Client tries to fetch the file from the Peer_Node. If the file is
> present with the Peer_Node, it will provide the file content to the
> Peer_Client and the Peer_Client will print the file content in its
> terminal. If not, Peer_Client will connect to the next Peer_Node and
> perform the above action.
>
> This will continue till the Peer_Client gets the file content or all
> the entries in the Relay_Server Response are exhausted.
>
> A short description about each Folder/File:
>
> **1.** Instructions has this readme.txt file which describes how to
> execute\
> **2.** Peer1 has 3 files:\
> **a.** peer1 is an executable file\
> **b.** peer_node.c is the source code file\
> **c.** sample1.txt is a random word file\
> **3.** The same holds for Peer 2 and Peer 3. Note that all c files are
> same, but all text files are different (both in name and content)\
> **4.** peer_client is the executable file for peer_client.c\
> **5.** relay_server is the executable file for relay_server.c\
> **6.** And the nodes are as peer1, peer2, peer3.
>
> Prototypes for all 3 files are as follows : (also mentioned in code
> comments)
>
> 1\. **Server :** \<executable code\> \<Server IP address\>\
> 2. **Peer(s):** \<executable code\> \<Server IP address\> \<Server
> Port Number\> 3. **Client :** \<executable code\> \<Server IP
> address\> \<Server Port Number\> \_serd
>
> **Instructions : (Procedure to compile and run)**
>
> **1.** First remove any .txt files that have been generated by a
> previous execution (namely nodesinfo.txt and nodeinfo_server.txt).
> These files are generated and are needed for code to work but might
> cause errors in subsequent execution.
>
> **2.** Then open 5 terminals, 2 in Group_10 and 3 in each of the
> peer1/2/3 directories.
>
> **3.** Then to generate the executable files (also already there) use
> the following : (compilation step)\
> **a.** Terminal 1: Group_10\$ gcc -o relay_server relay_server.c\
> **b.** Terminal 2: Group_10\$ gcc -o peer_client peer_client.c\
> **c.** Terminal 3: Group_10/peer1\$ gcc -o peer1 peer_node.c\
> **d.** Terminal 4: Group_10/peer2\$ gcc -o peer2 peer_node.c\
> **e.** Terminal 5: Group_10/peer3\$ gcc -o peer3 peer_node.c
>
> **4.** To execute do the following (in order).
>
> **a.** Terminal 1: Group_10\$ ./relay_server 8000\
> **b.** Terminal 3: Group_10/peer 1\$ ./peer 1 0.0.0.0 8000 **c.**
> Terminal 4: Group_10/peer 2\$ ./peer 2 0.0.0.0 8000 **d.** Terminal 5:
> Group_10/peer 3\$ ./peer 3 0.0.0.0 8000 **e.** Terminal 2: Group_10\$
> ./peer_client 0.0.0.0 8000
>
> **5.** Note that the server port can be anything as long as it\'s
> available. After running the peer_client, it\'ll interactively ask for
> the file name. If the file name matches with sample1.txt, or
> sample2.txt or sample3.txt, the content will be printed and the
> connection will close (for client and the corresponding nodes). The
> relay_server will however keep listening, for future connection
> requests. To make a future request, first clean the .txt files
> generated and then run the nodes/clients again
>
> A use of temux or a set of parallel terminals. All the terminals will
> have some of the applications running for a simultaneous connection
> scenario.
>
> Have the terminals run the following :

![](IMAGES/media/image2.png)

> **Terminal 1 :** Relay Server\
> **Terminal 2 :** Peer(s) \[add on the additional peers on next
> terminal window\] **Terminal 3 :** Peer Client
>
> **Compilation :**
>
> **Terminal 1 :** gcc relay_server.c -o server\
> **Terminal 2 :** gcc peer_client.c -o peerClient\
> **Terminal 3 :** gcc peer_node.c -o \<peer_no\>
>
> **Execution :**
>
> **Terminal 1 :** /server \<server_port\>\
> **Terminal 3 :** /\<peer_no\> \<serveraddress\> \<server_port\>\
> **Terminal 2 :** /client \<serveraddress\> \<serverport\>
>
> The requested file should be with a peer node because The client will
> ask for a file name and return the file if it is found with any node.
>
> **Output of Execution :**
>
> As per the stages discussed above we repeat the execution in a live
> environment presenting the below results.
>
> The server first boots up and and listens for connections.





> Now each of the peer nodes starts up waiting for the relay server to
> make the connection with the server.
>
> After the peers are loaded and relay clients run and make the
> connections between the server and the peer nodes.
>
> **Peer Node :**\
> ![](IMAGES/media/image3.png)
>
> **Relay Server :**\
> ![](IMAGES/media/image4.png)
>
> **Peer Client :**\
> ![](IMAGES/media/image5.png)
>
> Any Further request of files or data is sent to peers and upon the
> result of search the peer_client gets the information.
>
> The following is how the peer_client reacts to information.

![](IMAGES/media/image6.png)

> The above figure shows the connection of the peer did return the
> positive search and then the contents of the file are piped to the
> peer_client.
>
> The content of the file is displayed and for the current scenario it
> shuts down after the request has been handled.
>
>
